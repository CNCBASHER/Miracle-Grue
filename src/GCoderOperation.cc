/**
   MiracleGrue - Model Generator for toolpathing. <http://www.grue.makerbot.com>
   Copyright (C) 2011 Far McKon <Far@makerbot.com>, Hugo Boyer (hugo@makerbot.com)

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Affero General Public License as
   published by the Free Software Foundation, either version 3 of the
   License, or (at your option) any later version.

*/
#define __need_timeval

#include <assert.h>
#include <ctime>
#include <cmath>
#include <iomanip>

#include "GCoderOperation.h"

#include "mgl/segment.h"
#include "mgl/scadtubefile.h"
#include "mgl/abstractable.h"
#include "json-cpp/include/json/value.h"

using namespace std;
using namespace mgl;
using namespace Json;



/// other global static values.
static Value* GCoderOperationConfigRequirements;

/************** Start of Functions custom to this <NAME_OF>Operation ***********************/

// ToolHead is a state machine that knows
// where it is, and how fast its going


// function that adds an s to a noun if count is more than 1
std::string plural(const char*noun, int count, const char* ending = "s")
{
	string s(noun);
	if (count>1)
	{
		return s+ending;
	}
	return s;
}

void ToolHead::g1(std::ostream &ss, double x, double y, double z, double feed, const char *comment = NULL)
{
	bool doX=false;
	bool doY=false;
	bool doZ=false;
	bool doFeed=false;

	// cout << "ToolHead::g1" << endl;
	if(this->x >= MUCH_LARGER_THAN_THE_BUILD_PLATFORM)
	{
		doX = true;
		doY = true;
		doZ = true;
		doFeed = true;
	}

	if(!mgl::sameSame(this->x, x))
	{
		doX = true;
	}
	if(!mgl::sameSame(this->y, y))
	{
		doY=true;
	}
	if(!mgl::sameSame(this->z, z))
	{
		doZ=true;
	}

	if(!mgl::sameSame(this->feed, feed))
	{
		doFeed=true;
	}

	g1Motion(ss, x,y,z,feed,comment,doX,doY,doZ,doFeed);
}

void ToolHead::squirt(std::ostream &ss, const Point2D &lineStart, double extrusionSpeed)
{
	//ss << "M108 R" << this->fastExtrusionSpeed << endl;
	//ss << "M101 (squirt)" << endl;

	// int extruderSquirtDelay = 200;
	ss << "M108 R" << this->reversalExtrusionSpeed << " (squirt)" << endl;
	ss << "M101" << endl;
	g1(ss, lineStart.x, lineStart.y, z, fastFeedRate, NULL);
	ss << "M108 R" << extrusionSpeed << " (good to go)" << endl;
}

void ToolHead::snort(std::ostream &ss, const Point2D &lineEnd)
{
	double reversalFeedRate = this->fastFeedRate;
	ss << "M108 R" << this->reversalExtrusionSpeed << "  (snort)" << endl;
	ss << "M102" << endl;
	g1(ss, lineEnd.x, lineEnd.y, z, reversalFeedRate, NULL);
	ss << "M103" << endl;
}

//// writes an extruder reversal gcode snippet
//void reverseExtrude(std::ostream &ss, double feedrate)
//{
//	ss << "M108 R" << feedrate << endl;
//	ss << "M102 (reverse)" << endl;
//}
void ToolHead::g1Motion(std::ostream &ss, double x, double y, double z, double feed, const char *comment, bool doX, bool doY, bool doZ, bool doFeed)
{
	// not do something is not an option
	assert(doX || doY || doZ || doFeed);

	ss << "G1";
	if(doX) ss << " X" << x;
	if(doY) ss << " Y" << y;
	if(doZ) ss << " Z" << z;
	if(doFeed) ss << " F" << feed;
	if(comment) ss << " (" << comment << ")";

	ss << endl;

	// update state machine
	this->x = x;
	this->y = y;
	this->z = z;
	this->feed = feed;

	if(comment == NULL)
		this->comment = "";
	else
		this->comment = comment;

}




/************** End of Functions custom to this <NAME_OF>Operation ***********************/


/// This staic global pointer points to a unique instance of a
/// Value object, which contains the minimum configuration values
/// required to build a working operation of this type.
/// Must be named <OperationName>ConfigRequirements so it does not collide with



void GCoder::writeGcodeConfig(std::ostream &ss, const std::string indent) const
{
	MyComputer hal9000;

	ss << "(" << indent << "Generated by "<<  programName << " " << versionStr << ")"<< endl;
	ss << "(" << indent << hal9000.clock.now() <<  ")" << endl;

	ss << "(" << indent << "machine name: " << machineName << ")"<< endl;
	ss << "(" << indent << "firmware revision:" << firmware << ")" << endl;
	std::string plurial = extruders.size()? "":"s";
	ss << "(" << indent << extruders.size() << " extruder" << plurial << ")" << endl;
 	if (outline.enabled)
 	{
 		ss << "(" << indent << outline.distance << "mm outline" << ")" << endl;
 	}
 	else
 	{
 		ss << "(" << indent << "no outline" <<  ")"<< endl;
 	}
 	ss << endl;
}


void GCoder::loadData(const Configuration& conf)
{

	programName = conf.root["programName"].asString();
	versionStr  = conf.root["versionStr"].asString();
	machineName = conf.root["machineName"].asString();
	firmware    = conf.root["firmware"].asString();		// firmware revision
	gcodeFilename = conf.root["gcodeFilename"].asString();


	//fastFeed = conf.root["firmware"].asString();
	scalingFactor = conf.root["scalingFactor"].asDouble();

	platform.temperature = conf.root["platform"]["temperature"].asDouble();
	platform.automated   = conf.root["platform"]["automated"].asBool();
	platform.waitingPositionX = conf.root["platform"]["waitingPositionX"].asDouble();
	platform.waitingPositionY = conf.root["platform"]["waitingPositionY"].asDouble();
	platform.waitingPositionZ = conf.root["platform"]["waitingPositionZ"].asDouble();

	outline.enabled  = conf.root["outline"]["enabled"].asBool();
	outline.distance = conf.root["outline"]["distance"].asDouble();

	assert(conf.root["extruders"].size() >= 1);

	for(int i=0; i < conf.root["extruders"].size(); i++)
	{
		ToolHead toolHead;
		toolHead.coordinateSystemOffsetX = conf.root["extruders"][i]["waitingPositionZ"].asDouble();//(0
		toolHead.extrusionTemperature = conf.root["extruders"][i]["extrusionTemperature"].asDouble();//(220),
		toolHead.defaultExtrusionSpeed = conf.root["extruders"][i]["defaultExtrusionSpeed"].asDouble();//(3),
		toolHead.slowFeedRate = conf.root["extruders"][i]["slowFeedRate"].asDouble();//(1080),
		toolHead.slowExtrusionSpeed = conf.root["extruders"][i]["slowExtrusionSpeed"].asDouble();//(1.0),
		toolHead.fastFeedRate = conf.root["extruders"][i]["fastFeedRate"].asDouble();//;(3000),
		toolHead.fastExtrusionSpeed = conf.root["extruders"][i]["fastExtrusionSpeed"].asDouble();//(2.682),
		toolHead.nozzleZ = conf.root["extruders"][i]["nozzleZ"].asDouble();
		toolHead.reversalExtrusionSpeed = conf.root["extruders"][i]["reversalExtrusionSpeed"].asDouble();

		toolHead.leadIn = conf.root["extruders"][i]["leadIn"].asDouble();
		toolHead.leadOut = conf.root["extruders"][i]["leadOut"].asDouble();

		extruders.push_back(toolHead);
	}

}

/**
 * This is an accessor function to retreve a singleton of <OperationName>ConfigRequirements
 * if that dictionary does not exit, this function will generate it.
 * The returned dictionary specifies the minimum configuration settings needed to make a valid
 * initaliation of an Operation of this type
 *
 * @return global static Value pointer to configuration dictionary.
 */
Value* GCoderOperation::getStaticConfigRequirements()
{
	// if we don't have one of these global static's, we have never initalized,
	// so initalize now.
	if (GCoderOperationConfigRequirements == 0x00)
	{
		// - Start custom to GCoderOperation code
		// for this Example operation, we need a prefix and a language specified
		// to initalize
		Value* cfg = new Value;
//		( *cfg )["prefix"]= "asString";
//		( *cfg )["lang"] = "asString";
		// - End custom to GCoderOperation code
		GCoderOperationConfigRequirements = cfg;

		std::cout << __FUNCTION__ << std::endl;
		std::cout << "TODO: Create config Requirements" << std::endl;

		// This object is expected to live until the program dies. No deconstruction !
	}
	return GCoderOperationConfigRequirements;
}


/**
 * Standard Constructor.  Note that an object can be built and exist, but
 * not yet be configured or initalized. See details in implementation.
 * Anything things that do not need configuration
 * SHOULD be initalized in the constructor.
 */

GCoderOperation::GCoderOperation()
{
	// - Start custom to GCoderOperation code
	// Because this logging stream is always this file (and is not configuration dependant,
	//we build it in the constructor, and destroy it  in the destructor.

	this->acceptTypes.push_back(TYPE_PATH_BINARY);
	//this->emitTypes.push_back(); Left in as a note, but this example emits no data type

	// - End custom to GCoderOperation code

}


/**
 * Standard Destructor.  This should close streams (if any are open) and
 * deinitalize the Operation (if it is still initalized). See details in implementation.
 */
GCoderOperation::~GCoderOperation()
{
}



/**
 * This function takes a configuration object, and verifies that it can be used to
 * configure the object.
 * @param config
 * @return
 */
bool GCoderOperation::isValidConfig(Configuration& config) const
{

	cout << __FUNCTION__ << endl;
	return true;
}


/**
 * This function initalizes and configures this Operation to take data. Once this returns,
 * the operation may be sent data envelopes (via 'accept') at any time.  All streams, memory structures,
 * and related infrastructure for a specific processing setup must be created here.
 * @param config a configuration for setting up this operation
 * @param outputs a list of other Operations to send out outgoing packets to
 */
void GCoderOperation::init(Configuration& conf,const std::vector<Operation*> &outputs)
{
	bool baseSuccess = Operation::initCommon(conf, outputs);
	if(baseSuccess){
	// - Start custom to GCoderOperation code
		 gcoder.loadData(conf);
	// - End custom to GCoderOperation code
	}

}



/**
 * This function tears down everything setup in initalization. It will also check to see
 * if a stream is running, and if it is, it forces a final data envelope to be queued before
 * continuing with deiitalization. This will force a data flush in edge or fail cases.
 */
void GCoderOperation::deinit()
{
	assert(this->initalized == true);
	assert(this->pConfig != NULL);

	// IFF we have an ongoing stream, as we are being deinitalized, something went wrong.
	// force a final DataEnvelpe to our operation to flush the end of the stream.
	if(streamRunning)
	{
		// - Following line custom to GCoderOperation code
		cout << "Stream Running at deinit time. Automatically sending final envelope " << endl;

//		DataEnvelope d;
//		d.setFinal();
//		this->accept(d);
//		this->streamRunning = false;
//		d.release(); //release the constuctor default ref count of 1

	}

	// - Start custom to GCoderOperation code
	// - End custom to GCoderOperation code

	this->initalized = false;
	pConfig = NULL;
}

/**
 * This is the heart of envelope processing.
 * @param envelope
 */
void GCoderOperation::processEnvelope(const DataEnvelope& envelope)
{
	/// we should be configured before ever doing this
	assert(this->initalized == true);

	/// If this stream is not running, our first packet starts it running
	if( this->streamRunning == false) {
		this->streamRunning = true;
	}

	// - Start custom to GCoderOperation code

	cout << "TODO: test cast and/or flag type in GCoderOperation::processEnvelope" << endl;

	stringstream ss;
	const PathData &pathData = *(dynamic_cast<const PathData* > (&envelope) );
	gcoder.writeLayer(ss, pathData);
	wrapAndEmit(ss);

	cout << "TODO: test cast and/or flag type in GCoderOperation::processEnvelope" << endl;

	// - End custom to GCoderOperation code

	return;
}



void GCoderOperation::start(){

	// the first thing that needs to happen in start is the propigation of the
	// start to all other modueles.
	Operation::startCommon();

	// - Start custom to GCoderOperation code
	cout << "GCoderOperation::start() !!" << endl;
	stringstream ss;

	gcoder.writeGCodeConfig(ss);
	cout << "writeGCodeConfig"<< endl; // << ss.str() << endl;
	gcoder.writeMachineInitialization(ss);
	cout << "writeMachineInitialization" << endl; // << ss.str() << endl;
	gcoder.writeExtrudersInitialization(ss);
	cout << "writeExtrudersInitialization" << endl; // << ss.str() << endl;
	gcoder.writePlatformInitialization(ss);
	cout << "writePlatformInitialization" << endl; // << ss.str() << endl;
	gcoder.writeHomingSequence(ss);
	cout << "writeHomingSequence" << endl;// << ss.str() << endl;
	gcoder.writeWarmupSequence(ss);
	cout << "writeWarmupSequence" << endl;// << ss.str() << endl;
	gcoder.writeAnchor(ss);
	cout << "writeAnchor" << endl;// << ss.str() << endl;
	cout << endl << endl << "START ENV:" << endl << ss.str() << endl;


	wrapAndEmit(ss);
	// - End custom to GCoderOperation code

}

void GCoderOperation::finish(){

	// - Start custom to GCoderOperation code
	cout << "GCoderOperation::finish()"<< endl;
	stringstream ss;
	gcoder.writeGcodeEndOfFile(ss);

	wrapAndEmit(ss);

	// - End custom to GCoderOperation code

	// the last things to do in finish is propigate the finish
	// to all other modules.
	Operation::finishCommon();

}



Point2D unitVector(const Point2D& a, const Point2D& b)
{
	double dx = b.x - a.x;
	double dy = b.y - a.y;
	double length = sqrt(dx *dx + dy * dy);
	Point2D r(dx/length , dy/length);
	return r;
}

//
// computes 2 positions (one before and one at the end of) the polygon and stores them in start and stop.
// These positions are aligned with the fisrt line and last line of the polygon.
// LeadIn is the distance between start and the first point of the polygon (along the first polygon line).
// LeadOut is the distance between the last point of the Polygon and stop (along the last polygon line).
void polygonLeadInAndLeadOut(const Polygon &polygon, double leadIn, double leadOut, Point2D &start, Point2D &end)
{
	size_t count =  polygon.size();
	assert(count >= 2);

	const Point2D &a = polygon[0];	// first element
	const Point2D &b = polygon[1];

	const Point2D &c = polygon[count-2];
	const Point2D &d = polygon[count-1]; // last element

	Point2D ab = unitVector(a,b);
	Point2D cd = unitVector(c,d);

	start.x = a.x - ab.x * leadIn;
	start.y = a.y - ab.y * leadIn;
	end.x   = d.x + cd.x * leadOut;
	end.y   = d.y + cd.y * leadOut;

}

//
// Shouldn't z travel be guided by its own feed rate?
//

void GCoderOperation::writePaths(std::ostream& ss, int extruderId, double z, const ExtruderPaths &paths)
{
	gcoder.writePaths(ss,extruderId,z, paths);
}

void GCoder::writePaths(std::ostream& ss, int extruderId, double z, const ExtruderPaths &paths)
{
	GCoder &gcoder = *this;
	// to each extruder its speed
	double pathFeedrate = gcoder.scalingFactor * gcoder.extruders[extruderId].slowFeedRate;
	double extrusionSpeed = gcoder.scalingFactor * gcoder.extruders[extruderId].fastExtrusionSpeed;
	double leadIn = gcoder.extruders[extruderId].leadIn;
	double leadOut = gcoder.extruders[extruderId].leadOut;

	// moving all up. This is the first move for every new layer
	gcoder.extruders[extruderId].g1(ss,gcoder.extruders[extruderId].x,  gcoder.extruders[extruderId].y, z, pathFeedrate);

	int path_counter = 0;
	for (ExtruderPaths::const_iterator pathIt = paths.begin() ; pathIt != paths.end();  pathIt ++)
	{

		path_counter ++; // one based, FTU (for the user!)
		const Polygon &polygon = *pathIt;
		ss << "(  path " << path_counter << "/" << paths.size() << ", " << polygon.size() << " points, "  << " )" << endl;

		Point2D start(0,0), stop(0,0);
		polygonLeadInAndLeadOut(polygon, leadIn, leadOut, start, stop);

		gcoder.extruders[extruderId].g1(ss, start.x, start.y, z, gcoder.extruders[extruderId].fastFeedRate);
		//ss << "(START!)" << endl;
		gcoder.extruders[extruderId].squirt(ss, polygon[0], extrusionSpeed);
		//ss << "(!START)" << endl;
		for(int i=1; i < polygon.size(); i++)
		{
			const Point2D &p = polygon[i];
			gcoder.extruders[extruderId].g1(ss, p.x, p.y, z, pathFeedrate);
		}
		//ss << "(STOP!)" << endl;
		gcoder.extruders[extruderId].snort(ss, stop);
		//ss << "(!STOP)" << endl;
		ss << endl;
	}
}

/************** Start of Functions custom to GCoderOperation ***********************/

void GCoderOperation::writeLayer(ostream& ss, const PathData& pathData)
{
	gcoder.writeLayer(ss,pathData);
}

void GCoderOperation::writeSwitchExtruder(ostream& ss, int extruderId) const
{
	gcoder.writeSwitchExtruder(ss, extruderId);
}

void GCoderOperation::writeWipeExtruder(ostream& ss, int extruderId) const
{
	gcoder.writeWipeExtruder(ss, extruderId);
}


void GCoderOperation::writeExtrudersInitialization(std::ostream &ss) const
{
	gcoder.writeExtrudersInitialization(ss);
}

void GCoderOperation::writePlatformInitialization(std::ostream &ss) const
{
	gcoder.writePlatformInitialization(ss);
}

void GCoderOperation::writeGCodeConfig(std::ostream &ss) const
{
	gcoder.writeGCodeConfig(ss);
}

void GCoderOperation::writeMachineInitialization(std::ostream &ss) const
{
	gcoder.writeMachineInitialization(ss);
}


void GCoderOperation::writeHomingSequence(std::ostream &ss) const
{
	gcoder.writeHomingSequence(ss);
}

void GCoderOperation::writeWarmupSequence(std::ostream &ss)
{
	gcoder.writeWarmupSequence(ss);
}


void GCoderOperation::writeGcodeEndOfFile(std::ostream &ss) const
{
	gcoder.writeGcodeEndOfFile(ss);
}
void GCoderOperation::writeAnchor(std::ostream &ss)
{
	gcoder.writeAnchor(ss);
}


void GCoderOperation::wrapAndEmit(const stringstream &ss)
{
	GCodeEnvelope* data = new GCodeEnvelope(ss.str().c_str());
	emit(data);
	data->release();
}


void GCoder::writeLayer(ostream& ss, const PathData& pathData)
{
	GCoder &gcoder = *this;
	// distance above mid layer position of extruzion
	cout << endl << "GCoderOperation::writeLayer()" << endl;
	int extruderCount = pathData.paths.size();
	ss << "(PATHS for: " << extruderCount << plural("Extruder", extruderCount) << ")"<< endl;


	int extruderId = 0;

	cout << "Layer" << endl;
	for(std::vector<ExtruderPaths>::const_iterator extruderIt = pathData.paths.begin(); extruderIt != pathData.paths.end(); extruderIt++)
	{
		double z = pathData.positionZ + gcoder.extruders[extruderId].nozzleZ;

		if (pathData.paths.size() > 0)
		{
			writeSwitchExtruder(ss, extruderId);
		}

		const ExtruderPaths &paths = *extruderIt;
		writePaths(ss, extruderId, z, paths);


		if (pathData.paths.size() > 0)
		{
			writeWipeExtruder(ss, extruderId);
		}
		extruderId ++;
	}
}

void GCoder::writeSwitchExtruder(ostream& ss, int extruderId) const
{
	ss << "( extruder " << extruderId << " )" << endl;
	ss << "( GSWITCH T" << extruderId << " )" << endl;
	ss << endl;
}

void GCoder::writeWipeExtruder(ostream& ss, int extruderId) const
{
	ss << "( GWIPE my extruder #" << extruderId << " )"<< endl;
	ss << endl;
}

void GCoder::writeGCodeConfig(std::ostream &ss) const
{

	ss << endl;
	ss << "(Makerbot Industries)" << endl;
	ss << "(This file contains digital fabrication directives in gcode format)"<< endl;
	ss << "(For your 3D printer)" << endl;
	ss << "(http://wiki.makerbot.com/gcode)" <<  endl;
	writeGcodeConfig(ss, "* ");
	ss << endl;
}

void GCoder::writeMachineInitialization(std::ostream &ss) const
{
	ss <<  "G21 (set units to mm)" << endl;
	ss <<  "G90 (absolute positioning mode)" << endl;

	const GCoder &gcoder = *this;
	int toolHeadId = 0;
	if (gcoder.extruders.size() > 1)
	{
		for (std::vector<ToolHead>::const_iterator i= gcoder.extruders.begin(); i!=gcoder.extruders.end(); i++)
		{
			ToolHead t = *i;
			int coordinateSystemNb = toolHeadId +1;
			ss << "G10 P" << coordinateSystemNb << " X" <<  t.coordinateSystemOffsetX << " Y0 Z-0.3" << endl;
			toolHeadId ++;
		}
	}
	ss << endl;
}


void GCoder::writeExtrudersInitialization(std::ostream &ss) const
{
	const GCoder &gcoder = *this;
	string plural = "";
	if(gcoder.extruders.size()>1) plural = "s";
	ss << "(setup extruder" << plural <<")" <<endl;
	int toolHeadId = 0;
	for (std::vector<ToolHead>::const_iterator i= gcoder.extruders.begin(); i!=gcoder.extruders.end(); i++)
	{
		ToolHead t = *i;
		ss << "M103 T" << toolHeadId << " (Make sure motor for extruder " << toolHeadId << " is stopped)" << endl;
		ss << "M108 R" << t.defaultExtrusionSpeed << " T" << toolHeadId << " (set extruder " <<  toolHeadId << " speed to the default " << t.defaultExtrusionSpeed << " RPM)" << endl;
		ss << "M104 S" << t.extrusionTemperature  << " T" << toolHeadId << " (set temperature of extruder " << toolHeadId <<  " to "  << t.extrusionTemperature << " degrees Celsius)" << endl;
		ss << endl;
		toolHeadId ++;
	}
	ss << endl;
}


void GCoder::writePlatformInitialization(std::ostream &ss) const
{

	double t = platform.temperature;
	ss << "M109 S" << t << " T0 (heat the build-platform to "  << t << " Celsius)" << endl;
	ss << endl;

}


void GCoder::writeHomingSequence(std::ostream &ss) const
{
	const GCoder &gcoder = *this;

	ss << endl;
	ss << "(go to home position)" << endl;
	ss << "G162 Z F800 (home Z axis maximum)" << endl;
	ss << "G92 Z5 (set Z to 5)" << endl;
	ss << "G1 Z0.0 (move Z down 0)" << endl;
	ss << "G162 Z F100 (home Z axis maximum)" << endl;
	ss << "G161 X Y F2500 (home XY axes minimum)" << endl;
	ss << "M132 X Y Z A B (Recall stored home offsets for XYZAB axis)" << endl;
	if (gcoder.extruders.size() > 1)
		ss << "G54 (first work coordinate system)" << endl;
	ss << endl;
}

void GCoder::writeWarmupSequence(std::ostream &ss)
{
	GCoder &gcoder = *this;
	ss << endl;
	gcoder.extruders[0].g1(ss, 	gcoder.platform.waitingPositionX,
				gcoder.platform.waitingPositionY,
				gcoder.platform.waitingPositionZ,
				gcoder.extruders[0].fastFeedRate,
				"go to waiting position" );

	for (int i=0; i< gcoder.extruders.size(); i++)
	{
		ss << "M6 T" << i << " (wait for tool " << i<<" to reach temperature)" << endl;
	}
	ss << "(note: the heated build platform temperature is tied to tool 0 for now)" << endl;
	ss << endl;
	ss << endl;
}


void GCoder::writeGcodeEndOfFile(std::ostream &ss) const
{
	for (int i=0; i< extruders.size(); i++)
	{
		ss << "M104 S0 T" << i << " (set extruder temperature to 0)" << endl;
		ss << "M109 S0 T" << i << " (set heated-build-platform id tied an extrusion tool)" << endl;
	}

	ss << "G162 Z F500 (home Z axis maximum)" << endl;
	ss << "(That's all folks!)" << endl;
}

void GCoder::writeAnchor(std::ostream &ss)
{
	GCoder &gcoder = *this;
	ss << "(Create Anchor)" << endl;
	ss << "G1 Z0.6 F300    (Position Height)" << endl;
	ss << "M108 R4.0   (Set Extruder Speed)" << endl;
	ss << "M101        (Start Extruder)" << endl;
	ss << "G4 P1600" << endl;

	gcoder.extruders[0].g1( ss,
								gcoder.platform.waitingPositionX,
								gcoder.platform.waitingPositionY,
								0.6,
								gcoder.extruders[0].slowFeedRate,
								NULL );

	double dx = gcoder.platform.waitingPositionX - 3.0;
	double dy = gcoder.platform.waitingPositionY - 0.0;

	gcoder.extruders[0].g1(ss, dx, dy, 0.6, 0.2 * gcoder.extruders[0].slowFeedRate , NULL);
	ss << endl;
}


/*
double dist(double x0, double y0, double x1, double y1)
{
	return sqrt( (x1-x0)*(x1-x0) + (y1-y0) * (y1-y0) );
}
*/



