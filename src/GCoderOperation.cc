/**
   MiracleGrue - Model Generator for toolpathing. <http://www.grue.makerbot.com>
   Copyright (C) 2011 Far McKon <Far@makerbot.com>, Hugo Boyer (hugo@makerbot.com)

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Affero General Public License as
   published by the Free Software Foundation, either version 3 of the
   License, or (at your option) any later version.

*/
#define __need_timeval

#include <assert.h>
#include <ctime>
#include <cmath>
#include <iomanip>

#include "GCoderOperation.h"

#include "mgl/segment.h"
#include "mgl/scadtubefile.h"
#include "mgl/abstractable.h"
#include "json-cpp/include/json/value.h"

using namespace std;
using namespace mgl;
using namespace Json;




/// other global static values.
static Value* GCoderOperationConfigRequirements;

/************** Start of Functions custom to this <NAME_OF>Operation ***********************/

// ToolHead is a state machine that knows
// where it is, and how fast its going




void ToolHead::g1(std::ostream &ss, double x, double y, double z, double feed, const char *comment = NULL)
{
	bool doX=false;
	bool doY=false;
	bool doZ=false;
	bool doFeed=false;


	if(this->x >= MUCH_LARGER_THAN_THE_BUILD_PLATFORM)
	{
		doX = true;
		doY = true;
		doZ = true;
		doFeed = true;
	}

	if(!mgl::sameSame(this->x, x))
	{
		doX = true;
	}
	if(!mgl::sameSame(this->y, y))
	{
		doY=true;
	}
	if(!mgl::sameSame(this->z, z))
	{
		doZ=true;
	}

	if(!mgl::sameSame(this->feed, feed))
	{
		doFeed=true;
	}

	g1Motion(ss, x,y,z,feed,comment,doX,doY,doZ,doFeed);
}

void ToolHead::squirt(std::ostream &ss, const Vector2 &lineStart, double extrusionSpeed)
{
	//ss << "M108 R" << this->fastExtrusionSpeed << endl;
	//ss << "M101 (squirt)" << endl;

	// int extruderSquirtDelay = 200;
	ss << "M108 R" << this->reversalExtrusionSpeed << " (squirt)" << endl;
	ss << "M101" << endl;
	g1(ss, lineStart.x, lineStart.y, z, fastFeedRate, NULL);
	ss << "M108 R" << extrusionSpeed << " (good to go)" << endl;
}

void ToolHead::snort(std::ostream &ss, const Vector2 &lineEnd)
{
	double reversalFeedRate = this->fastFeedRate;
	ss << "M108 R" << this->reversalExtrusionSpeed << "  (snort)" << endl;
	ss << "M102" << endl;
	g1(ss, lineEnd.x, lineEnd.y, z, reversalFeedRate, NULL);
	ss << "M103" << endl;
}



//// writes an extruder reversal gcode snippet
//void reverseExtrude(std::ostream &ss, double feedrate)
//{
//	ss << "M108 R" << feedrate << endl;
//	ss << "M102 (reverse)" << endl;
//}
void ToolHead::g1Motion(std::ostream &ss, double x, double y, double z, double feed, const char *comment, bool doX, bool doY, bool doZ, bool doFeed)
{

	// not do something is not an option
	#ifdef STRONG_CHECKING
		assert(doX || doY || doZ || doFeed);
	#endif

	assert(fabs(x) < 10000000);
	assert(fabs(y) < 10000000);
	assert(fabs(z) < 10000000);



	ss << "G1";
	if(doX) ss << " X" << x;
	if(doY) ss << " Y" << y;
	if(doZ) ss << " Z" << z;
	if(doFeed) ss << " F" << feed;
	if(comment) ss << " (" << comment << ")";

	ss << endl;

	// update state machine
	this->x = x;
	this->y = y;
	this->z = z;
	this->feed = feed;

	if(comment == NULL)
		this->comment = "";
	else
		this->comment = comment;

}




/************** End of Functions custom to this <NAME_OF>Operation ***********************/


/// This staic global pointer points to a unique instance of a
/// Value object, which contains the minimum configuration values
/// required to build a working operation of this type.
/// Must be named <OperationName>ConfigRequirements so it does not collide with



void GCoder::writeGcodeConfig(std::ostream &ss, const std::string indent) const
{
	MyComputer hal9000;

	ss << "(" << indent << "Generated by "<<  programName << " " << versionStr << ")"<< endl;
	ss << "(" << indent << hal9000.clock.now() <<  ")" << endl;

	ss << "(" << indent << "machine name: " << machineName << ")"<< endl;
	ss << "(" << indent << "firmware revision:" << firmware << ")" << endl;
	std::string plurial = extruders.size()? "":"s";
	ss << "(" << indent << extruders.size() << " extruder" << plurial << ")" << endl;
 	if (outline.enabled)
 	{
 		ss << "(" << indent << outline.distance << "mm outline" << ")" << endl;
 	}
 	else
 	{
 		ss << "(" << indent << "no outline" <<  ")"<< endl;
 	}
 	ss << endl;
}


void GCoder::loadData(const Configuration& conf)
{

	programName = conf.root["programName"].asString();
	versionStr  = conf.root["versionStr"].asString();
	machineName = conf.root["machineName"].asString();
	firmware    = conf.root["firmware"].asString();		// firmware revision
	gcodeFilename = conf.root["gcodeFilename"].asString();

	homing.xyMaxHoming = conf.root["homing"]["xyMaxHoming"].asBool();
	homing.zMaxHoming  = conf.root["homing"]["zMaxHoming" ].asBool();

	//fastFeed = conf.root["firmware"].asString();
	scalingFactor = conf.root["scalingFactor"].asDouble();

	platform.temperature = conf.root["platform"]["temperature"].asDouble();
	platform.automated   = conf.root["platform"]["automated"].asBool();
	platform.waitingPositionX = conf.root["platform"]["waitingPositionX"].asDouble();
	platform.waitingPositionY = conf.root["platform"]["waitingPositionY"].asDouble();
	platform.waitingPositionZ = conf.root["platform"]["waitingPositionZ"].asDouble();

	outline.enabled  = conf.root["outline"]["enabled"].asBool();
	outline.distance = conf.root["outline"]["distance"].asDouble();

	assert(conf.root["extruders"].size() >= 1);

	unsigned int extruderCount = conf.root["extruders"].size();
	for(int i=0; i < extruderCount; i++)
	{
		ToolHead toolHead;
		toolHead.coordinateSystemOffsetX = conf.root["extruders"][i]["waitingPositionZ"].asDouble();//(0
		toolHead.extrusionTemperature = conf.root["extruders"][i]["extrusionTemperature"].asDouble();//(220),
		toolHead.defaultExtrusionSpeed = conf.root["extruders"][i]["defaultExtrusionSpeed"].asDouble();//(3),
		toolHead.slowFeedRate = conf.root["extruders"][i]["slowFeedRate"].asDouble();//(1080),
		toolHead.slowExtrusionSpeed = conf.root["extruders"][i]["slowExtrusionSpeed"].asDouble();//(1.0),
		toolHead.fastFeedRate = conf.root["extruders"][i]["fastFeedRate"].asDouble();//;(3000),
		toolHead.fastExtrusionSpeed = conf.root["extruders"][i]["fastExtrusionSpeed"].asDouble();//(2.682),
		toolHead.nozzleZ = conf.root["extruders"][i]["nozzleZ"].asDouble();
		toolHead.reversalExtrusionSpeed = conf.root["extruders"][i]["reversalExtrusionSpeed"].asDouble();

		toolHead.leadIn = conf.root["extruders"][i]["leadIn"].asDouble();
		toolHead.leadOut = conf.root["extruders"][i]["leadOut"].asDouble();

		extruders.push_back(toolHead);
	}

}

/**
 * This is an accessor function to retreve a singleton of <OperationName>ConfigRequirements
 * if that dictionary does not exit, this function will generate it.
 * The returned dictionary specifies the minimum configuration settings needed to make a valid
 * initaliation of an Operation of this type
 *
 * @return global static Value pointer to configuration dictionary.
 */
Value* GCoderOperation::getStaticConfigRequirements()
{
	// if we don't have one of these global static's, we have never initalized,
	// so initalize now.
	if (GCoderOperationConfigRequirements == 0x00)
	{
		// - Start custom to GCoderOperation code
		// for this Example operation, we need a prefix and a language specified
		// to initalize
		Value* cfg = new Value;
//		( *cfg )["prefix"]= "asString";
//		( *cfg )["lang"] = "asString";
		// - End custom to GCoderOperation code
		GCoderOperationConfigRequirements = cfg;

		std::cout << __FUNCTION__ << std::endl;
		std::cout << "TODO: Create config Requirements" << std::endl;

		// This object is expected to live until the program dies. No deconstruction !
	}
	return GCoderOperationConfigRequirements;
}


/**
 * Standard Constructor.  Note that an object can be built and exist, but
 * not yet be configured or initalized. See details in implementation.
 * Anything things that do not need configuration
 * SHOULD be initalized in the constructor.
 */

GCoderOperation::GCoderOperation()
{
	// - Start custom to GCoderOperation code
	// Because this logging stream is always this file (and is not configuration dependant,
	//we build it in the constructor, and destroy it  in the destructor.

	this->acceptTypes.push_back(TYPE_PATH_BINARY);
	//this->emitTypes.push_back(); Left in as a note, but this example emits no data type

	// - End custom to GCoderOperation code

}


/**
 * Standard Destructor.  This should close streams (if any are open) and
 * deinitalize the Operation (if it is still initalized). See details in implementation.
 */
GCoderOperation::~GCoderOperation()
{
}



/**
 * This function takes a configuration object, and verifies that it can be used to
 * configure the object.
 * @param config
 * @return
 */
bool GCoderOperation::isValidConfig(Configuration& config) const
{

	cout << __FUNCTION__ << endl;
	return true;
}


/**
 * This function initalizes and configures this Operation to take data. Once this returns,
 * the operation may be sent data envelopes (via 'accept') at any time.  All streams, memory structures,
 * and related infrastructure for a specific processing setup must be created here.
 * @param config a configuration for setting up this operation
 * @param outputs a list of other Operations to send out outgoing packets to
 */
void GCoderOperation::init(Configuration& conf,const std::vector<Operation*> &outputs)
{
	bool baseSuccess = Operation::initCommon(conf, outputs);
	if(baseSuccess){
	// - Start custom to GCoderOperation code
		 gcoder.loadData(conf);
	// - End custom to GCoderOperation code
	}

}



/**
 * This function tears down everything setup in initalization. It will also check to see
 * if a stream is running, and if it is, it forces a final data envelope to be queued before
 * continuing with deiitalization. This will force a data flush in edge or fail cases.
 */
void GCoderOperation::deinit()
{
	assert(this->initalized == true);
	assert(this->pConfig != NULL);

	// IFF we have an ongoing stream, as we are being deinitalized, something went wrong.
	// force a final DataEnvelpe to our operation to flush the end of the stream.
	if(streamRunning)
	{
		// - Following line custom to GCoderOperation code
		cout << "Stream Running at deinit time. Automatically sending final envelope " << endl;

//		DataEnvelope d;
//		d.setFinal();
//		this->accept(d);
//		this->streamRunning = false;
//		d.release(); //release the constuctor default ref count of 1

	}

	// - Start custom to GCoderOperation code
	// - End custom to GCoderOperation code

	this->initalized = false;
	pConfig = NULL;
}

/**
 * This is the heart of envelope processing.
 * @param envelope
 */
void GCoderOperation::processEnvelope(const DataEnvelope& envelope)
{
	assert(0);
}

void GCoderOperation::accept(const PathData& envelope)
{
	/// we should be configured before ever doing this
	assert(this->initalized == true);

	/// If this stream is not running, our first packet starts it running
	if( this->streamRunning == false) {
		this->streamRunning = true;
	}

	// - Start custom to GCoderOperation code

	//cout << "TODO: test cast and/or flag type in GCoderOperation::processEnvelope" << endl;

	stringstream ss;
// 	const PathData &pathData = *(dynamic_cast<const PathData* > (&envelope) );
	const SliceData &pathData = *(dynamic_cast<const SliceData* > (&envelope) );

	gcoder.writeSlice(ss, pathData);
	wrapAndEmit(ss);

	//cout << "TODO: test cast and/or flag type in GCoderOperation::processEnvelope" << endl;

	// - End custom to GCoderOperation code

	return;
}



void GCoderOperation::start(){

	// the first thing that needs to happen in start is the propigation of the
	// start to all other modueles.
	Operation::startCommon();

	// - Start custom to GCoderOperation code
	cout << "GCoderOperation::start() !!" << endl;
	stringstream ss;

	gcoder.writeStartOfFile(ss);


	wrapAndEmit(ss);
	// - End custom to GCoderOperation code

}

void GCoderOperation::finish(){

	// - Start custom to GCoderOperation code
	cout << "GCoderOperation::finish()"<< endl;
	stringstream ss;
	gcoder.writeGcodeEndOfFile(ss);

	wrapAndEmit(ss);

	// - End custom to GCoderOperation code

	// the last things to do in finish is propigate the finish
	// to all other modules.
	Operation::finishCommon();

}



Vector2 unitVector(const Vector2& a, const Vector2& b)
{
	double dx = b.x - a.x;
	double dy = b.y - a.y;
	double length = sqrt(dx *dx + dy * dy);
	Vector2 r(dx/length , dy/length);
	return r;
}

//
// computes 2 positions (one before and one at the end of) the polygon and stores them in start and stop.
// These positions are aligned with the fisrt line and last line of the polygon.
// LeadIn is the distance between start and the first point of the polygon (along the first polygon line).
// LeadOut is the distance between the last point of the Polygon and stop (along the last polygon line).
void polygonLeadInAndLeadOut(const Polygon &polygon, double leadIn, double leadOut, Vector2 &start, Vector2 &end)
{
	size_t count =  polygon.size();
	assert(count >= 2);

	const Vector2 &a = polygon[0];	// first element
	const Vector2 &b = polygon[1];

	const Vector2 &c = polygon[count-2];
	const Vector2 &d = polygon[count-1]; // last element

	Vector2 ab = unitVector(a,b);
	Vector2 cd = unitVector(c,d);

	start.x = a.x - ab.x * leadIn;
	start.y = a.y - ab.y * leadIn;
	end.x   = d.x + cd.x * leadOut;
	end.y   = d.y + cd.y * leadOut;

}



void GCoder::writePaths(std::ostream& ss,
							unsigned int sliceIndex,
							unsigned int extruderId,
							double z,
							const Polygons &paths)
{
	GCoder &gcoder = *this;
	// to each extruder its speed
	double pathFeedrate = gcoder.scalingFactor * gcoder.extruders[extruderId].slowFeedRate;
	double extrusionSpeed = gcoder.scalingFactor * gcoder.extruders[extruderId].fastExtrusionSpeed;
	double leadIn = gcoder.extruders[extruderId].leadIn;
	double leadOut = gcoder.extruders[extruderId].leadOut;

	// moving all up. This is the first move for every new layer
	gcoder.extruders[extruderId].g1(ss,gcoder.extruders[extruderId].x,  gcoder.extruders[extruderId].y, z, pathFeedrate);

	int path_counter = 0;
	for (Polygons::const_iterator pathIt = paths.begin() ; pathIt != paths.end();  pathIt ++)
	{

		path_counter ++; // one based, FTU (for the user!)
		const Polygon &polygon = *pathIt;
		ss << "(  slice " << sliceIndex << " , path " << path_counter << "/" << paths.size() << ", " << polygon.size() << " points, "  << " )" << endl;

		Vector2 start(0,0), stop(0,0);
		polygonLeadInAndLeadOut(polygon, leadIn, leadOut, start, stop);

		gcoder.extruders[extruderId].g1(ss, start.x, start.y, z, gcoder.extruders[extruderId].fastFeedRate);
		//ss << "(START!)" << endl;
		gcoder.extruders[extruderId].squirt(ss, polygon[0], extrusionSpeed);
		//ss << "(!START)" << endl;
		for(int i=1; i < polygon.size(); i++)
		{
			const Vector2 &p = polygon[i];
			gcoder.extruders[extruderId].g1(ss, p.x, p.y, z, pathFeedrate);
		}
		//ss << "(STOP!)" << endl;
		gcoder.extruders[extruderId].snort(ss, stop);
		//ss << "(!STOP)" << endl;
		ss << endl;
	}
}

/************** Start of Functions custom to GCoderOperation ***********************/

void GCoderOperation::wrapAndEmit(const stringstream &ss)
{
	GCodeEnvelope* data = new GCodeEnvelope(ss.str().c_str());
	emit(data);
	data->release();
}








